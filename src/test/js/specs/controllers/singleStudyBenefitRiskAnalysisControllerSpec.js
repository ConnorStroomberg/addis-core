define(['angular', 'angular-mocks', 'controllers'], function() {  describe("The Single Study Benefit-Risk AnalysisController", function() {    var scope,      mockWindow,      currentAnalysis,      outcomeResource,      select2UtilService,      interventionResource,      trialverseStudyResource,      problemResource,      singleStudyBenefitRiskAnalysisService,      mockOutcome1,      mockOutcome2,      mockIntervention1,      mockIntervention2,      mockAnalysis,      mockProject,      mockStudy1,      mockStudy2,      mockStudies,      mockOutcomes,      outcomesDeferred,      mockInterventions,      interventionsDeferred,      mockProblem,      projectDeferred,      analysisDeferred,      scenarioDeferred,      ctrl,      state,      problemDeferred,      DEFAULT_VIEW = 'DEFAULT_VIEW  ';    beforeEach(module('addis.controllers'));    beforeEach(inject(function($controller, $q, $rootScope) {      mockOutcome1 = {        id: 1,        name: 'mockOutcome1',        semanticOutcome: 'mockSemantic1'      };      mockOutcome2 = {        id: 2,        name: 'mockOutcome2',        semanticOutcome: 'mockSemantic2'      };      mockIntervention1 = {        id: 1,        name: 'mockIntervention1',        semanticIntervention: 'mockSemantic1'      };      mockIntervention2 = {        id: 2,        name: 'mockIntervention2',        semanticIntervention: 'mockSemantic2'      };      mockAnalysis = {        name: 'analysisName',        type: 'Single-study Benefit-Risk',        study: null,        selectedOutcomes: [mockOutcome1],        selectedInterventions: [mockIntervention1],        $save: function() {}      };      mockProject = {        id: 1,        name: 'projectName',        owner: {          id: 1        }      };      mockStudy1 = {        id: 1      };      mockStudy2 = {        id: 2      };      mockProblem = {        alternatives: []      };      mockStudies = [mockStudy1, mockStudy2];      mockOutcomes = [mockOutcome1, mockOutcome2];      mockInterventions = [mockIntervention1, mockIntervention2];      var mockStateParams = {        projectId: mockProject.id,        analysisId: mockAnalysis.id      };      scope = $rootScope;      state = jasmine.createSpyObj('state', ['go']);      outcomeResource = jasmine.createSpyObj('outcomeResource', ['query']);      outcomeResource.query.and.returnValue(mockOutcomes);      interventionResource = jasmine.createSpyObj('interventionResource', ['query']);      interventionResource.query.and.returnValue(mockInterventions);      select2UtilService = jasmine.createSpyObj('select2UtilService', ['idsToObjects', 'objectsToIds']);      select2UtilService.objectsToIds.and.returnValue(['1']);      trialverseStudyResource = jasmine.createSpyObj('trialverseStudyResource', ['query', 'get']);      trialverseStudyResource.query.and.returnValue(mockStudies);      problemResource = jasmine.createSpyObj('problemResource', ['get']);      problemResource.get.and.returnValue(mockProblem);      singleStudyBenefitRiskAnalysisService = jasmine.createSpyObj('singleStudyBenefitRiskAnalysisService', ['getProblem', 'getDefaultScenario', 'validateAnalysis', 'validateProblem']);      scenarioDeferred = $q.defer();      singleStudyBenefitRiskAnalysisService.getDefaultScenario.and.returnValue(scenarioDeferred.promise);      singleStudyBenefitRiskAnalysisService.getProblem.and.returnValue(scenarioDeferred.promise);      projectDeferred = $q.defer();      mockProject.$promise = projectDeferred.promise;      analysisDeferred = $q.defer();      mockAnalysis.$promise = analysisDeferred.promise;      problemDeferred = $q.defer();      mockProblem.$promise = problemDeferred.promise;      mockWindow = {        config: {          user: {            id: 1          }        }      };      outcomesDeferred = $q.defer();      mockOutcomes.$promise = outcomesDeferred.promise;      interventionsDeferred = $q.defer();      mockInterventions.$promise = interventionsDeferred.promise;      scope.$parent = {        analysis: mockAnalysis,        project: mockProject,        editMode:{          disableEditing:true        }      };      currentAnalysis = mockAnalysis;      spyOn(mockAnalysis, '$save');      ctrl = $controller('SingleStudyBenefitRiskAnalysisController', {        $scope: scope,        $stateParams: mockStateParams,        $state: state,        $q: $q,        $window: mockWindow,        'OutcomeResource': outcomeResource,        'InterventionResource': interventionResource,        'Select2UtilService': select2UtilService,        'TrialverseStudyResource': trialverseStudyResource,        'ProblemResource': problemResource,        'SingleStudyBenefitRiskAnalysisService': singleStudyBenefitRiskAnalysisService,        'DEFAULT_VIEW': DEFAULT_VIEW      });    }));    it('should place a list of outcomes on the scope when it is loaded', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      outcomesDeferred.resolve(mockOutcomes);      scope.$apply();      expect(scope.outcomes).toEqual(mockOutcomes);    });    it('should place a list of interventions on the scope when it is loaded', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      interventionsDeferred.resolve(mockInterventions);      scope.$apply();      expect(scope.interventions).toEqual(mockInterventions);    });    it('should not set project and analysis information before they are loaded', function() {      expect(scope.selectedOutcomeIds).toBeUndefined();      expect(scope.selectedInterventionIds).toBeUndefined();    });    it('should place project information on the scope', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      expect(scope.project).toEqual(mockProject);    });    it('should place analysis information on the scope', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      expect(scope.analysis).toEqual(mockAnalysis);    });    it('should place selectedOutcomeId information on the scope', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      outcomesDeferred.resolve(mockOutcomes);      scope.$apply();      expect(scope.selectedOutcomeIds).toEqual(['1']);    });    it('should place selectedInterventionId information on the scope', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      interventionsDeferred.resolve(mockInterventions);      scope.$apply();      expect(scope.selectedInterventionIds).toEqual(['1']);    });    it('should place a list of studies on the scope when the project is loaded', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      expect(scope.studies).toEqual(mockStudies);    });    it('should save the analysis when the selected outcomes change', function() {      select2UtilService.idsToObjects.and.returnValue([mockOutcome1, mockOutcome2]);      analysisDeferred.resolve();      projectDeferred.resolve();      interventionsDeferred.resolve(mockInterventions);      outcomesDeferred.resolve(mockOutcomes);      scope.$apply();      scope.selectedOutcomeIds = ['1', '2'];      scope.$apply();      scope.dirty = true;      expect(scope.analysis.selectedOutcomes).toEqual([mockOutcome1, mockOutcome2]);      expect(scope.analysis.$save).toHaveBeenCalled();    });    it('should save the analysis when the selected interventions change', function() {      select2UtilService.idsToObjects.and.returnValue([mockIntervention1, mockIntervention2]);      analysisDeferred.resolve();      projectDeferred.resolve();      interventionsDeferred.resolve(mockInterventions);      outcomesDeferred.resolve(mockOutcomes);      scope.$apply();      scope.selectedInterventionIds = ['1', '2'];      scope.$apply();      expect(scope.analysis.selectedInterventions).toEqual([mockIntervention1, mockIntervention2]);      expect(scope.analysis.$save).toHaveBeenCalled();    });    it('should save the analysis when the selected study changes', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      scope.analysis.studyUid = 1;      scope.$apply();      expect(scope.analysis.$save).toHaveBeenCalled();    });    it('should make createProblem accessible once the analysis and project are available.', function() {      expect(scope.createProblem).toBeUndefined();      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      expect(scope.createProblem).toBeDefined();    });    it('should call the singleStudyBenefitRiskAnalysisService.createProblem when createProblem is called', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      scope.createProblem(mockAnalysis);      expect(singleStudyBenefitRiskAnalysisService.getProblem).toHaveBeenCalledWith(mockAnalysis);    });    it('should go to the default view when goToOverView is called', function() {      var mockScenario = {        id: 1      };      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      scope.goToDefaultScenarioView();      scenarioDeferred.resolve(mockScenario);      scope.$apply();      expect(singleStudyBenefitRiskAnalysisService.getDefaultScenario).toHaveBeenCalled();      expect(state.go).toHaveBeenCalledWith(DEFAULT_VIEW, {        id: mockScenario.id      });    });    it('should place an error message on the scope when the analysis problem is not valid', function() {      singleStudyBenefitRiskAnalysisService.validateProblem.and.returnValue(false);      expect(scope.errorMessage.text).toBeUndefined();      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      scope.createProblem(mockAnalysis);      scenarioDeferred.resolve({});      scope.$apply();      expect(scope.errorMessage.text).toBeDefined();    });    describe('should remove the error message from the scope', function() {      beforeEach(function() {        analysisDeferred.resolve();        projectDeferred.resolve();        interventionsDeferred.resolve(mockInterventions);        outcomesDeferred.resolve(mockOutcomes);        scope.$apply();      });      it('when the selectedInterventions change', function() {        scope.errorMessage.text = 'message';        scope.selectedInterventionIds.push(1);        scope.$apply();        expect(scope.errorMessage.text).toBeUndefined();      });      it('when the selectedOutcomes change', function() {        scope.errorMessage.text = 'message';        scope.selectedOutcomeIds.push(1);        scope.$apply();        expect(scope.errorMessage.text).toBeUndefined();      });      it('when the selected study changes', function() {        scope.errorMessage.text = 'message';        scope.analysis.studyUid = 37;        scope.$apply();        expect(scope.errorMessage.text).toBeUndefined();      });    });  });});