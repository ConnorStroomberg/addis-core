define(['angular', 'angular-mocks', 'controllers', 'jQuery'], function() {  describe("The analysisController", function() {    var scope, location, mockWindow,      analysisService, projectsService, outcomeService,      select2UtilService, interventionService, trialverseStudyService, problemService,      mockOutcome1,      mockOutcome2,      mockIntervention1,      mockIntervention2,      mockAnalysis,      mockProject,      mockStudy1,      mockStudy2,      mockStudies,      mockOutcomes,      mockInterventions,      mockProblem,      projectDeferred,      analysisDeferred,      ctrl,      baseUrl = '/baseUrl';    beforeEach(module('addis.controllers'));    beforeEach(inject(function($controller, $q, $rootScope, _$location_) {      mockOutcome1 = {        id: 1,        name: 'mockOutcome1',        semanticOutcome: 'mockSemantic1'      };      mockOutcome2 = {        id: 2,        name: 'mockOutcome2',        semanticOutcome: 'mockSemantic2'      };      mockIntervention1 = {        id: 1,        name: 'mockIntervention1',        semanticIntervention: 'mockSemantic1'      };      mockIntervention2 = {        id: 2,        name: 'mockIntervention2',        semanticIntervention: 'mockSemantic2'      };      mockAnalysis = {        name: 'analysisName',        type: 'Single-study Benefit-Risk',        study: null,        selectedOutcomes: [mockOutcome1],        selectedInterventions: [mockIntervention1],        $save: function() {}      };      mockProject = {        id: 1,        name: 'projectName',        owner: {          id: 1        }      };      mockStudy1 = {        id: 1      };      mockStudy2 = {        id: 2      };      mockProblem = {        alternatives: []      };      mockStudies = [mockStudy1, mockStudy2];      mockOutcomes = [mockOutcome1, mockOutcome2];      mockInterventions = [mockIntervention1, mockIntervention2];      var mockStateParams = {        projectId: mockProject.id,        analysisId: mockAnalysis.id      };      scope = $rootScope;      location = _$location_;      location.url(baseUrl);      analysisService = jasmine.createSpyObj('analysisService', ['get', 'save']);      analysisService.get.and.returnValue(mockAnalysis);      projectsService = jasmine.createSpyObj('projectService', ['get']);      projectsService.get.and.returnValue(mockProject);      outcomeService = jasmine.createSpyObj('outcomeService', ['query']);      outcomeService.query.and.returnValue(mockOutcomes);      interventionService = jasmine.createSpyObj('interventionService', ['query']);      interventionService.query.and.returnValue(mockInterventions);      select2UtilService = jasmine.createSpyObj('select2UtilService', ['idsToObjects', 'objectsToIds']);      select2UtilService.objectsToIds.and.returnValue(['1']);      trialverseStudyService = jasmine.createSpyObj('trialverseStudyService', ['query', 'get']);      trialverseStudyService.query.and.returnValue(mockStudies);      problemService = jasmine.createSpyObj('problemService', ['get']);      problemService.get.and.returnValue(mockProblem);      projectDeferred = $q.defer();      mockProject.$promise = projectDeferred.promise;      analysisDeferred = $q.defer();      mockAnalysis.$promise = analysisDeferred.promise;      problemDeferred = $q.defer();      mockProblem.$promise = problemDeferred.promise;      mockWindow = {        config: {          user: {            id: 1          }        }      };      spyOn(mockAnalysis, '$save');      ctrl = $controller('AnalysisController', {        $scope: scope,        $stateParams: mockStateParams,        $window: mockWindow,        $location: _$location_,        'ProjectsService': projectsService,        'AnalysisService': analysisService,        'OutcomeService': outcomeService,        'InterventionService': interventionService,        'Select2UtilService': select2UtilService,        'TrialverseStudyService': trialverseStudyService,        'ProblemService': problemService,        'jQuery': jQuery      });    }));    it('should only make loading.loaded true when both project and analysis are loaded', function() {      expect(scope.loading.loaded).toBeFalsy();      projectDeferred.resolve();      scope.$apply();      expect(scope.loading.loaded).toBeFalsy();      analysisDeferred.resolve();      scope.$apply();      expect(scope.loading.loaded).toBeTruthy();    });    it('should place a list of outcomes on the scope when it is loaded', function() {      expect(scope.outcomes).toEqual(mockOutcomes);    });    it('should place a list of interventions on the scope when it is loaded', function() {      expect(scope.interventions).toEqual(mockInterventions);    });    it('should not set project and analysis information before they are loaded', function() {      expect(scope.selectedOutcomeIds).toEqual([]);      expect(scope.selectedInterventionIds).toEqual([]);    });    it('should place project information on the scope', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      expect(scope.project).toEqual(mockProject);    });    it('should place analysis information on the scope', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      expect(scope.analysis).toEqual(mockAnalysis);    });    it('should place selectedOutcomeId information on the scope', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      expect(scope.selectedOutcomeIds).toEqual(['1']);    });    it('should place selectedOutcomeId information on the scope', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      expect(scope.selectedInterventionIds).toEqual(['1']);    });    it('should place a list of studies on the scope when the project is loaded', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      expect(scope.studies).toEqual(mockStudies);    });    it('should save the analysis when the selected outcomes change', function() {      select2UtilService.idsToObjects.and.returnValue([mockOutcome1, mockOutcome2]);      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      scope.selectedOutcomeIds = ['1', '2'];      scope.$apply();      scope.dirty = true;      expect(scope.analysis.selectedOutcomes).toEqual([mockOutcome1, mockOutcome2]);      expect(scope.analysis.$save).toHaveBeenCalled();    });    it('should save the analysis when the selected interventions change', function() {      select2UtilService.idsToObjects.and.returnValue([mockIntervention1, mockIntervention2]);      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      scope.selectedInterventionIds = ['1', '2'];      scope.$apply();      expect(scope.analysis.selectedInterventions).toEqual([mockIntervention1, mockIntervention2]);      expect(scope.analysis.$save).toHaveBeenCalled();    });    it('should save the analysis when the selected study changes', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      scope.analysis.studyId = 1;      scope.$apply();      expect(scope.analysis.$save).toHaveBeenCalled();    });    it('should allow editing owned analyses', function() {      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      expect(scope.project.owner.id).toEqual(mockWindow.config.user.id);      expect(scope.editMode.disableEditing).toBeFalsy();    });    it('should not allow editing of non-owned analyses', function() {      mockProject.owner = {        id: 2      };      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      expect(scope.editMode.disableEditing).toBeTruthy();    });    it('should not allow editing of an analysis with a defined problem', function() {      mockAnalysis.problem = {        foo: 'bar'      };      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      expect(scope.editMode.disableEditing).toBeTruthy();    });    it('should place a problem in the analysis when createProblem is called', function() {      var mockScenario = {id: 1};      mockAnalysis.scenarios = [mockScenario];      mockAnalysis.$save = function(callback) {        callback(mockAnalysis);      };      spyOn(mockAnalysis, '$save').and.callThrough();      analysisDeferred.resolve();      projectDeferred.resolve();      scope.$apply();      scope.createProblem();      problemDeferred.resolve();      scope.$apply();      expect(scope.analysis.problem).toEqual(mockProblem);      expect(scope.analysis.$save).toHaveBeenCalled();      expect(location.url()).toEqual(baseUrl + '/scenarios/' + scope.analysis.scenarios[0].id);    });  });});